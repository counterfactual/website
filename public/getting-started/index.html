<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <title>Counterfactual</title>
  <link rel="stylesheet" href="/app.css">
</head>

<body>
  <div class="wrapper">

    <!-- Navbar -->
    <div class="section--nav">
      <div class="container">

        <div class="nav">
          <h1 class="nav__left">
            <a href="/" alt="Counterfactual">
              <!-- Use inline svg to avoid Safari svg rendering error -->
              <svg height="1" viewBox="0 0 607.455522 606.993078" xmlns="http://www.w3.org/2000/svg"
                xmlns:xlink="http://www.w3.org/1999/xlink">
                <defs>
                  <path id="a" d="m0 0h606v606h-606z" />
                  <path id="b"
                    d="m39.490566 39.5652174v129.9139126h122.080528v-129.9139126zm161.571094 149.1334786c0 11.208676-9.119736 20.345652-20.307264 20.345652h-160.4471318c-11.16960824 0-20.3072642-9.121998-20.3072642-20.345652v-168.3530438c0-11.20563312 9.12277376-20.3456522 20.3072642-20.3456522h160.4471318c1.231816.01977015 1.231816.01977015 2.505397.12979324 4.120897.458743 8.123056 1.90224371 11.94836 5.73477913 3.825304 3.83253543 5.266082 7.84225963 5.723959 11.97094663.109816 1.2759893.109816 1.2759893.12434 1.9206422.003756.2922425.005492 56.6064207.005208 168.9425348zm69.612755-91.2130438-52.546755-80.7982609c-.841452-.846087-.841452-1.6891304-.561981-2.8152174.28251-1.4091304 1.685944-2.8152174 3.371887-3.3782609l26.133642-9.29173909c2.809905-.84304347 6.181792.28304348 7.588264 2.25217392l63.783339 98.53565217.28251.28c.841453 1.126087.841453 2.535217 0 3.661304l-64.065849 98.815653c-1.685944 2.252173-4.778359 3.37826-7.588264 2.252173l-26.695623-9.008695c-1.403434-.563044-2.527396-1.409131-3.089377-2.815218-.28251-.563043-.561982-1.972174.279471-3.37826l53.108736-80.518261c3.092415-4.221305 3.092415-9.851739 0-13.7930438z" />
                  <mask id="c" fill="#fff">
                    <use fill="none" xlink:href="#a" />
                  </mask>
                  <mask id="d" fill="#fff">
                    <use fill="none" xlink:href="#b" />
                  </mask>
                </defs>
                <g fill="none" fill-rule="evenodd">
                  <use fill="#101010" xlink:href="#a" />
                  <g fill="#101010" mask="url(#c)">
                    <path d="m0 0h645v648h-645z" transform="translate(-12.12 -9.09)" />
                  </g>
                  <g transform="translate(142 200)">
                    <use fill="#fff" fill-rule="nonzero" xlink:href="#b" />
                    <g fill="#fff" mask="url(#d)">
                      <path d="m0 0h346v347h-346z" transform="translate(-12.150943 -70)" />
                    </g>
                  </g>
                </g>
              </svg>
            </a>
          </h1>

          <!-- #if desktop -->
          <nav class="nav__right mobile-off">
            <a class="nav__right__item" href="/technology">technology.</a>
            <a class="nav__right__item" href="/team">team.</a>
            <a class="nav__right__item" href="/statechannels">state channels.</a>
            <a class="nav__right__item" target="_blank" href="https://specs.counterfactual.com">specs.</a>
            <a class="nav__right__item" target="_blank" href="http://github.com/counterfactual">github.</a>
            <a class="nav__right__item" target="_blank" href="http://counterfactual.com/chat">chat.</a>
            <a class="nav__right__item" target="_blank" href="https://medium.com/statechannels">blog.</a>
          </nav>
          <!-- /if desktop -->

          <!-- #if mobile -->
          <div class="nav__right mobile-only menu-btn">
            <button class="nav__right__item">menu</button>
          </div>
          <!-- /if mobile -->
        </div>

        <div class="mobile-menu mobile-only">
          <button class="mobile-menu__close">close</button>
          <a class="mobile-menu__item" href="/technology">technology.</a>
          <a class="mobile-menu__item" href="/team">team.</a>
          <a class="mobile-menu__item" href="/statechannels">state channels.</a>
          <a class="mobile-menu__item" target="_blank" href="https://specs.counterfactual.com">specs.</a>
          <a class="mobile-menu__item" target="_blank" href="http://github.com/counterfactual">github.</a>
          <a class="mobile-menu__item" target="_blank" href="http://counterfactual.com/chat">chat.</a>
          <a class="mobile-menu__item" target="_blank" href="https://medium.com/statechannels">blog.</a>
        </div>
      </div>
    </div>
    <!-- End Navbar -->

    <!-- Page Content -->
    <div class="wrapper__content">
      <div class="section">
        <div class="container">

          <div id="markdown">
<h1 id="counterfactualgettingstartedguide">Counterfactual Getting Started Guide</h1>
<h2 id="introduction">Introduction</h2>
<p>Counterfactual is a development framework that makes it easy to build dapps on Ethereum using generalized state channels. State channels are an “off-chain” or “layer 2” technique that allow your dapp to be instant and gas-cheap, while still retaining the security of an on-chain application. [ https://www.counterfactual.com/statechannels/ ]</p>
<p>State channels are particularly useful for any dapp that manages turn-based conditional transactions between a fixed set of users. For instance, a dapp where users play a game against each other for money.</p>
<p>In this guide, we’ll build a simple game dapp using the Counterfactual framework. The game is called High Roller: a dice game where two users stake ETH, then roll two dice, with the higher roll taking all of the staked money.</p>
<p>To streamline the guide, we’ve built a bot to automatically accept requests to play High Roller; this means you only have to code the UI for the first player (the one who proposes to play the game).</p>
<h3 id="howdoescounterfactualwork">How does Counterfactual work?</h3>
<p>For users, Counterfactual provides a safe central wallet in Metamask for state-channel funds and for tracking state in open channels.</p>
<p>For developers, Counterfactual disentangles the UI of the dapp from the formal logic of the game being implemented.</p>
<h3 id="forusers">For Users</h3>
<p>Users install the Counterfactual Metamask plugin, which creates an Ethereum address in Metamask for their Counterfactual dapp funds. Funds in this account are used to fund the individual (virtual) channels that players choose to open in a specific Counterfactual app.</p>
<h3 id="fordevelopers">For Developers</h3>
<p>The logic of the game, things like</p>
<ol>
<li>whose turn is it now?</li>
<li>how does a player action modify game state?</li>
<li>when is the game over?</li>
<li>what happens when the game is over?</li>
</ol>
<p>are implemented by pure functions in <strong>HighRoller.sol</strong>. The solidity contract has already been written, and can be found <a href="https://github.com/counterfactual/monorepo/blob/master/packages/apps/contracts/HighRollerApp.sol">here</a>.</p>
<p>The UI for the game, including things like</p>
<ol>
<li>proposing a game to another user</li>
<li>accepting a proposal from another user</li>
<li>taking an action when it is your turn</li>
<li>listening for other players to take their turns</li>
<li>leaving a game when it’s over</li>
</ol>
<p>are implemented in <strong>HighRoller.js</strong></p>
<p>Counterfactual nodes implement the interactions between these two components</p>
<p>dapp UI ( HighRoller.js ) < -- 1 -- > Counterfactual (Node) < -- 2 -- > GameLogic (HighRoller.sol)</p>
<p>in three ways:</p>
<ol>
<li><strong>S</strong><strong>tarting a channel</strong> - When users request / agree to play a game, the UI passes the request (via connection 1) to the Counterfactual node. The node then instantiates a state channel based on the game logic described by the contract (connection 2).</li>
<li><strong>S</strong><strong>tate management in a channel</strong> - In an open channel, requests to modify state are passed to the CF node (via connection 1). The node uses the pure functions of the solidity contract (via connection 2) to verify that requests to modify state are valid, and to alter the state accordingly. The node makes updated state available to members of the channel (via connection 1).</li>
<li><strong>E</strong><strong>nding a game</strong>  - When the game is over, the dapp (HighRoller.js) must request (via 1) that the node end the game. In turn, the CF node will (via 2) verify that the game is over, and if it is over, have the contract implement the transactions that resolve the game.</li>
</ol>
<h3 id="inthisgettingstartguideyoulllearnhowto">In this Getting Start Guide, you’ll learn how to:</h3>
<ol>
<li>Instantiate a Counterfactual NodeProvider</li>
<li>Connect the NodeProvider to a blockchain contract through an AppFactory instance</li>
<li>Use the AppFactory’s <code>.proposeInstallVirtual()</code> method to propose a virtual state channel based on the AppFactory instance’s blockchain contract and settings</li>
<li>Use the NodeProvider’s <code>.on()</code>  method to listen for accepted installs and updated state in the channel</li>
<li>Use the AppInstance’s <code>.takeAction()</code> method to propose updates to state in the channel</li>
<li>Use the AppInstance’s <code>.unin``s``tall()</code> method to propose closing and resolving the channel</li>
</ol>
<hr />
<h1 id="highrollerjs">HighRoller.js</h1>
<h2 id="truffleunbox">Truffle unbox</h2>
<p>We’ll start our new Counterfactual project with the template in the Counterfactual truffle box. Looking through the template, you’ll find:</p>
<ul>
<li>some initialized variables ( <code>let web3Provider, nodeProvider;</code> )</li>
<li>the async function <code>run()</code> which contains calls to<ul>
<li>initWeb3() // initializes web3; already complete and explained inline</li>
<li>initContract() // <strong>this is where we point to the blockchain contract for our state channel</strong> - we’ll explain and fill in the details during the guide</li>
<li>setupCF() // setup for the Counterfactual NodeProvider; already complete</li>
<li>install() // <strong>this is the game</strong> - we’ll explain and fill this in<ul>
<li>The install function will call the rest of the functions in the doc</li></ul></li></ul></li>
<li>a call to the <code>run()</code> function</li>
</ul>
<hr />
<h2 id="constants">Constants</h2>
<p>We’ll import some ethereum constants and utilities we’ll need to write High Roller:</p>
<ul>
<li>HashZero (the ethers.js bytes32 representation of zero)</li>
<li>bigNumberify (returns Big Number types from input; we’ll use these because JavaScript is, by default, not able to handle big number representations accurately)</li>
<li>parseEther (converts the string representation of Ether into BigNumber instance of the amount of Wei)</li>
<li>solidityKeccak256 (solidity hash function)</li>
<li>fromExtendedKey (creates an ethereum wallet-like object [HDNode] from an extended private or public key)</li>
</ul>
<pre><code>const { HashZero } = ethers.constants;
const { bigNumberify, parseEther, solidityKeccak256 } = ethers.utils;
const { fromExtendedKey } = ethers.utils.HDNode;

const contractAddress = '0x91907355C59BA005843E791c88aAB80b779446c9';
const numberSalt =
"0xdfdaa4d168f0be935a1e1d12b555995bc5ea67bd33fce1bc5be0a1e0a381fc90";


let web3Provider, nodeProvider;

async function run() {
  await initWeb3();
  await initContract();
  await setupCF();
  await install();
}
</code></pre>
<hr />
<h2 id="initweb3">initWeb3()</h2>
<pre><code>async function initWeb3() {
  // Modern dapp browsers...
  if (window.ethereum) {
    web3Provider = window.ethereum;
    try {
      // Request account access
      await window.ethereum.enable();
    } catch (error) {
      // User denied account access...
      console.error("User denied account access")
    }
  }
  // Legacy dapp browsers...
  else if (window.web3) {
    web3Provider = window.web3.currentProvider;
  }
  // If no injected web3 instance is detected, fall back to Ganache
  else {
    web3Provider = new Web3.providers.HttpProvider('http://localhost:8545');
  }
  web3 = new Web3(web3Provider);
}
</code></pre>
<hr />
<h2 id="initcontract">initContract()</h2>
<p>This is where we point our HighRoller app to the corresponding HighRoller contract on the ethereum blockchain.</p>
<pre><code>async function initContract() {
  let res = await fetch('HighRollerApp.json')
  let HighRollerAppArtifact = await res.json();
  let HighRollerApp = TruffleContract(HighRollerAppArtifact);

  // Set the provider for our contract
  HighRollerApp.setProvider(web3Provider);
}
</code></pre>
<hr />
<h2 id="setupcf">setupCF()</h2>
<p>We set up a Counterfactual NodeProvider.</p>
<pre><code>// COUNTERFACTUAL
async function setupCF() {
  nodeProvider = new cf.NodeProvider();
  await nodeProvider.connect();
}
</code></pre>
<hr />
<h2 id="install">install()</h2>
<p>This is where we begin coding the game.</p>
<p>The install function will</p>
<ul>
<li><p>reset game state</p></li>
<li><p>instantiate a new cfProvider</p></li>
<li><p>instantiate an appFactory instance of our HighRoller contract. To do this,  we’ll need</p>
<ul>
<li>the address of our contract (good thing we set it up!)</li>
<li>the encodings for the game (we don’t quite know these until we figure out more about the game, so we’ll have to wait until later to fill this in)</li>
<li>and the cfProvider</li></ul>
<p>async function install() {
  resetGameState();</p>
<p>let cfProvider = new cf.Provider(nodeProvider);
  let appFactory = new cf.AppFactory(contractAddress, {
    actionEncoding: " ",
    stateEncoding: " "
  }, cfProvider);
}</p></li>
</ul>
<p>We’ll define the function <code>resetGameState()</code> once we have a better sense of what that will entail.</p>
<p>The install() function will also call <code>proposeInstall(appFactory)</code>. This function will implement <code>appFactory.proposeInstallVirtual()</code> method; it asks the Counterfactual node to instantiate a (virtual) state channel based on the blockchain contract specified in <code>appFactory</code>. To call this method, we’ll need to specify</p>
<ul>
<li>the initial state for the game (we’ll have to fill this in after we look at the High Roller contract)</li>
<li>who is playing</li>
<li>what are the stakes (and in what currency)</li>
<li>how long before timeout</li>
<li>the intermediary</li>
</ul>
<pre><code>async function install() {
  resetGameState();

  let cfProvider = new cf.Provider(nodeProvider);
  let appFactory = new cf.AppFactory(contractAddress, {
    actionEncoding: " ",
    stateEncoding: " "
  }, cfProvider);

  proposeInstall(appFactory);
}

async function proposeInstall(appFactory) {
  const { intermediary, nodeAddress } = await getOpponentData();
  const depositAmount = '0.00001';
  const initialState = {};

  await appFactory.proposeInstallVirtual({
    initialState,
    proposedToIdentifier: nodeAddress,
    asset: {
      assetType: 0 /* AssetType.ETH */
    },
    peerDeposit: parseEther(depositAmount),
    myDeposit: parseEther(depositAmount),
    timeout: 172800,
    intermediaries: [intermediary]
  });
}
</code></pre>
<p>The install() function is also where we instruct the cfProvider to <strong>listen</strong> in the channel for</p>
<ul>
<li>successful installVirtual</li>
<li>changes in state in the channel</li>
</ul>
<p>and to react to those changes via the method  <code>.on(listenFor, respondWith() )</code>.</p>
<pre><code>async function install() {
  resetGameState();

  let cfProvider = new cf.Provider(nodeProvider);
  let appFactory = new cf.AppFactory(contractAddress, {
    actionEncoding: " ",
    stateEncoding: " "
  }, cfProvider);

  proposeInstall(appFactory);

  cfProvider.on('installVirtual', onInstallEvent);
  cfProvider.on('updateState', onUpdateEvent);
}
</code></pre>
<p>When cfProvider detects ‘installVirtual’ is successful (when the bot accepts our proposeInstallVirtual) it calls the function <strong>onInstallEvent().</strong> When it detects updates in state in the virtualChannel, it calls <strong>onUpdateEvent().</strong>  This is the in-channel state management mechanism for Interface 1.</p>
<hr />
<h2 id="oninstallevent">onInstallEvent()</h2>
<p>When the cfProvider confirms our proposed install has been accepted, we reveal the “Roll the dice” button for our player to use.</p>
<pre><code>async function onInstallEvent(event) {
  currentGame.appInstance = event.data.appInstance;

  revealButton();
}
</code></pre>
<p>Now we’ll take a quick look at the blockchain contract to see how the game logic is structured.</p>
<hr />
<h1 id="highrollersol">HighRoller.sol</h1>
<hr />
<h2 id="gamelogicforhighrollersol">Game logic for HighRoller.sol</h2>
<p>We want to make our dice game very secure: the die rolls for both players will be determined by the contract. Each player submits a number, and the contract uses those two numbers as a distributed random-number generator to generate the die rolls we need. This only works if both players are ignorant of their opponents submission. In order to remove any advantage from the second player, we plan the structure of HighRoller</p>
<ul>
<li>the first player <strong>submits a hash</strong> of their <strong>number</strong> with a <strong>salt</strong></li>
<li>the second player <strong>submits</strong> their <strong>number</strong></li>
<li>the first player <strong>reveals</strong> their number (by submitting both the number and the salt, which are checked against the original hash)</li>
<li>the contract generates die rolls and distributes money to the winner</li>
</ul>
<p>The information above is enough to determine the ActionType, Stage, AppState, and Action for the game.</p>
<pre><code>//solidity

contract HighRollerApp is CounterfactualApp {

  enum ActionType {
    START_GAME,
    COMMIT_TO_HASH,
    COMMIT_TO_NUM,
    REVEAL
  }

  enum Stage {
    PRE_GAME,
    COMMITTING_HASH,
    COMMITTING_NUM,
    REVEALING,
    DONE
  }

  enum Player {
    FIRST,
    SECOND
  }

  struct AppState {
    address[2] playerAddrs;
    Stage stage;
    bytes32 salt;
    bytes32 commitHash;
    uint256 playerFirstNumber;
    uint256 playerSecondNumber;
  }

  struct Action {
    ActionType actionType;
    uint256 number;
    bytes32 actionHash;
  }
</code></pre>
<p>Because it’s such a simple game (player1 → player2 → player1 → done), getTurnTaker() and isStateTerminal() are both quite simple.</p>
<pre><code>//solidity

  function isStateTerminal(AppState memory state)
    public
    pure
    returns (bool)
  {
    return state.stage == Stage.DONE;
  }

  function getTurnTaker(AppState memory state)
    public
    pure
    returns (Player)
  {
    return state.stage == Stage.COMMITTING_NUM ? Player.SECOND : Player.FIRST;
  }
</code></pre>
<p>Actions for the game are defined in the applyAction function</p>
<pre><code>//solidity

  function applyAction(AppState memory state, Action memory action)
    public
    pure
    returns (bytes memory)
  {
    AppState memory nextState = state;
    if (action.actionType == ActionType.START_GAME) {
      require(
        state.stage == Stage.PRE_GAME,
        "Cannot apply START_GAME on PRE_GAME"
      );
      nextState.stage = Stage.COMMITTING_HASH;
    } else if (action.actionType == ActionType.COMMIT_TO_HASH) {
      require(
        state.stage == Stage.COMMITTING_HASH,
        "Cannot apply COMMIT_TO_HASH on COMMITTING_HASH"
      );
      nextState.stage = Stage.COMMITTING_NUM;

      nextState.commitHash = action.actionHash;
    } else if (action.actionType == ActionType.COMMIT_TO_NUM) {
      require(
        state.stage == Stage.COMMITTING_NUM,
        "Cannot apply COMMITTING_NUM on COMMITTING_NUM"
      );
      nextState.stage = Stage.REVEALING;

      nextState.playerSecondNumber = action.number;
    } else if (action.actionType == ActionType.REVEAL) {
      require(
      state.stage == Stage.REVEALING
      "Cannot apply REVEALING on REVEALING"
      );
      nextState.stage = Stage.DONE;

      nextState.playerFirstNumber = action.playerFirstNumber;
      nextState.salt = action.salt;
    } else {
      revert("Invalid action type");
    }
    return abi.encode(nextState);
  }
</code></pre>
<p>You should also take a look at <code>highRoller(randomness)</code> which takes in the deterministic “random” seed made from the submitted player numbers and outputs the totals for each player.</p>
<pre><code>//solidity

function highRoller(bytes32 randomness)
    public
    pure
    returns(uint8 playerFirstTotal, uint8 playerSecondTotal)
  {
    (bytes8 hash1, bytes8 hash2,
    bytes8 hash3, bytes8 hash4) = cutBytes32(randomness);
    playerFirstTotal = bytes8toDiceRoll(hash1) + bytes8toDiceRoll(hash2);
    playerSecondTotal = bytes8toDiceRoll(hash3) + bytes8toDiceRoll(hash4);
  }
</code></pre>
<p>Back to the javascript.</p>
<hr />
<h1 id="highrollerjs-1">HighRoller.js</h1>
<hr />
<h2 id="encodinginitialstateandresetgamestate">encoding, initial state, and resetGameState()</h2>
<p>Now that we know what HighRoller.sol looks like, we can fill in the encoding for the game:</p>
<pre><code>async function install() {
  resetGameState();

  let cfProvider = new cf.Provider(nodeProvider);
  let appFactory = new cf.AppFactory(contractAddress, {
    actionEncoding: "tuple(uint8 actionType, uint256 number, bytes32 actionHash)",
    stateEncoding: "tuple(address[2] playerAddrs, uint8 stage, bytes32 salt, bytes32 commitHash, uint256 playerFirstNumber, uint256 playerSecondNumber)"
  }, cfProvider);

  proposeInstall(appFactory);

  cfProvider.on('installVirtual', onInstallEvent);
  cfProvider.on('updateState', onUpdateEvent);
}
</code></pre>
<p>We can also describe the initiateState:</p>
<pre><code>async function proposeInstall(appFactory) {
  const { intermediary, nodeAddress } = await getOpponentData();
  const betAmount = '0.00001'; //in ETH
  const initialState = {
      playerAddrs: [
        deriveAddress(
          account.nodeAddress
        ),
        deriveAddress(
          nodeAddress
        )
      ],
      stage: HighRollerStage.PRE_GAME,
      salt: HashZero,
      commitHash: HashZero,
      playerFirstNumber: 0,
      playerSecondNumber: 0
    },

  await appFactory.proposeInstallVirtual({
  initialState,
  proposedToIdentifier: nodeAddress,
  asset: {
    assetType: 0 /* AssetType.ETH */
  },
  peerDeposit: parseEther(betAmount),
  myDeposit: parseEther(betAmount),
  timeout: 172800,
  intermediaries: [intermediary]
  });
}
</code></pre>
<p>and a game reset:</p>
<pre><code>let web3Provider, nodeProvider, currentGame;

...

function resetGameState() {
  currentGame = {
    highRollerState: {
      stage: HighRollerStage.PRE_GAME
    }
  };
}
</code></pre>
<hr />
<h2 id="referencingactionandstage">referencing action and stage</h2>
<p>Since solidity uses enums, we create a dictionary to make implementing actions and referencing stages easier for ourselves</p>
<pre><code>const { HashZero } = ethers.constants;
const { bigNumberify, parseEther, solidityKeccak256 } = ethers.utils;
const { fromExtendedKey } = ethers.utils.HDNode;

const HighRollerAction = {
  START_GAME: 0,
  COMMIT_TO_HASH: 1,
  COMMIT_TO_NUM: 2,
  REVEAL: 3
}

const HighRollerStage = {
  PRE_GAME: 0,
  COMMITTING_HASH: 1,
  COMMITTING_NUM: 2,
  REVEALING: 3,
  DONE: 4
};
</code></pre>
<hr />
<h2 id="roll">roll()</h2>
<p>Finally, we’re ready to return to rolling the dice. This button will do a few things:</p>
<ol>
<li>it moves the game forward from PRE<em>GAME to COMMITTING</em>HASH by the START_GAME action</li>
<li>then, since it’s still our player’s turn, we’ll need to take the COMMIT<em>TO</em>HASH action, which involves<ol>
<li>generating our player’s number</li>
<li>generating our player’s salt</li>
<li>submitting to the contract (with the COMMIT<em>TO</em>HASH action) the hash of our number and salt</li></ol></li>
</ol>
<p>We’ll use the as-yet undefined takeAction function to do this, which will need data specified for each of the three data types in the Action data structure.</p>
<p>The START_GAME action only uses the ActionType, so we leave the rest as zero:</p>
<pre><code>async function roll() {
  disableButton();

  if (currentGame.highRollerState.stage === HighRollerStage.PRE_GAME) {
    await takeAction({
      number: 0,
      actionType: HighRollerAction.START_GAME,
      actionHash: HashZero
    });
}
</code></pre>
<p>While the COMMIT<em>TO</em>HASH uses both its type and actionHash:</p>
<pre><code>async function roll() {
  disableButton();

  if (currentGame.highRollerState.stage === HighRollerStage.PRE_GAME) {
    await takeAction({
      number: 0,
      actionType: HighRollerAction.START_GAME,
      actionHash: HashZero
    });

    const playerFirstNumber = generatePlayerNumber();

    await takeAction({
      number: 0,
      actionType: HighRollerAction.COMMIT_TO_HASH,
      actionHash: solidityKeccak256(
        ["bytes32", "uint256"],
        [numberSalt, playerFirstNumber]
      )
    });
}

async function takeAction(params) {
  currentGame.highRollerState = (await currentGame.appInstance.takeAction(
    params
  ));
}
</code></pre>
<p>This completes the first move in the game. Now we wait for the bot to receive the state in COMMITTING_NUM stage and move it into REVEALING</p>
<hr />
<h2 id="onupdateevent">onUpdateEvent()</h2>
<p>Presumably, the bot has received our state, committed their number and moved the game into the REVEALING stage. We need to code our player’s REVEAL action for the REVEALING stage, and then we need to code for the end of the game in the DONE stage.</p>
<pre><code>async function onUpdateEvent({ data }) {
  const highRollerState = {
    ...data.newState,
    playerFirstNumber: currentGame.playerFirstNumber
  };

  if (highRollerState.stage === HighRollerStage.REVEALING) {
    await revealDice(highRollerState);
  } else if (highRollerState.stage === HighRollerStage.DONE) {
    await completeGame(highRollerState);
  }
}
</code></pre>
<hr />
<h2 id="revealdice">revealDice()</h2>
<p>We reveal dice by taking the REVEAL action and submitting with it our number and salt</p>
<pre><code>async function revealDice(highRollerState) {
  await currentGame.appInstance.takeAction({
    actionType: HighRollerAction.REVEAL,
    actionHash: numberSalt,
    number: highRollerState.playerFirstNumber.toString()
  });
}
</code></pre>
<hr />
<h2 id="completegame">completeGame()</h2>
<p>The completeGame() function will do two things:</p>
<ul>
<li>triggers the resolution of the solidity contract</li>
<li>retrieve information about the conclusion of the game from the solidity contract, so that it can present this information to the user.</li>
</ul>
<p><code>executeContract()</code> is a UI function. we read in the contract, and apply the winning condition function (called <strong>highRoller()</strong> ) to the random seed we generated (playerFirstNumber * playerSecondNumber)</p>
<p><code>appInstance.uninstall()</code> is a call to trigger the <strong>resolve()</strong> function in HighRoller.sol (which triggers any financial consequences/transactions).</p>
<pre><code>async function completeGame(highRollerState) {
  const rolls = await executeContract(
    highRollerState.playerFirstNumber,
    highRollerState.playerSecondNumber
  );

  const { myRoll, opponentRoll } = determineRolls(highRollerState, rolls);
  const gameState = determineGameState(myRoll, opponentRoll);

  updateUIState({
    myRoll,
    opponentRoll,
    gameState,
    highRollerState
  });

  await currentGame.appInstance.uninstall(currentGame.appInstance.intermediaries[0]);

  resetApp();
}


async function executeContract(
  num1,
  num2
) {
  const randomness = solidityKeccak256(["uint256"], [num1.mul(num2)]);

  // Connect to the network
  const provider = new ethers.providers.Web3Provider(web3.currentProvider);

  // We connect to the Contract using a Provider, so we will only
  // have read-only access to the Contract. We also specify the contract method.

  const abi = [
  "function highRoller(bytes32 randomness) public pure returns(uint8 playerFirstTotal, uint8 playerSecondTotal)"
];

  const contract = new ethers.Contract(contractAddress, abi, provider);

  const result = await contract.highRoller(randomness);

  return {
    playerFirstRoll: getDieNumbers(result[0]),
    playerSecondRoll: getDieNumbers(result[1])
  };
}
</code></pre>
<hr />
<p>The rest is good old UI for the game.</p>
<pre><code>const { HashZero } = ethers.constants;
const { bigNumberify, parseEther, solidityKeccak256 } = ethers.utils;
const { fromExtendedKey } = ethers.utils.HDNode;

const HighRollerAction = {
  START_GAME: 0,
  COMMIT_TO_HASH: 1,
  COMMIT_TO_NUM: 2,
  REVEAL: 3
}

const HighRollerStage = {
  PRE_GAME: 0,
  COMMITTING_HASH: 1,
  COMMITTING_NUM: 2,
  REVEALING: 3,
  DONE: 4
};

const contractAddress = '0x91907355C59BA005843E791c88aAB80b779446c9';
const numberSalt =
"0xdfdaa4d168f0be935a1e1d12b555995bc5ea67bd33fce1bc5be0a1e0a381fc90";

let web3Provider, nodeProvider, currentGame, account;

async function run() {
  account = await getUserData();

  bindEvents();
  await initWeb3();
  await initContract();
  await setupCF();
  await install();
}


// GENERAL ETH SETUP
function bindEvents() {
  document.querySelector('#rollBtn').addEventListener("click", roll);
}

async function initWeb3() {
  // Modern dapp browsers...
  if (window.ethereum) {
    web3Provider = window.ethereum;
    try {
      // Request account access
      await window.ethereum.enable();
    } catch (error) {
      // User denied account access...
      console.error("User denied account access")
    }
  }
  // Legacy dapp browsers...
  else if (window.web3) {
    web3Provider = window.web3.currentProvider;
  }
  // If no injected web3 instance is detected, fall back to Ganache
  else {
    web3Provider = new Web3.providers.HttpProvider('http://localhost:8545');
  }
  web3 = new Web3(web3Provider);
}

async function initContract() {
  let res = await fetch('HighRollerApp.json')
  let HighRollerAppArtifact = await res.json();
  let HighRollerApp = TruffleContract(HighRollerAppArtifact);

  // Set the provider for our contract
  HighRollerApp.setProvider(web3Provider);
}


// COUNTERFACTUAL
async function setupCF() {
  nodeProvider = new cf.NodeProvider();
  await nodeProvider.connect();
}

async function install() {
  resetGameState();

  let cfProvider = new cf.Provider(nodeProvider);
  let appFactory = new cf.AppFactory(contractAddress, {
    actionEncoding: "tuple(uint8 actionType, uint256 number, bytes32 actionHash)",
    stateEncoding: "tuple(address[2] playerAddrs, uint8 stage, bytes32 salt, bytes32 commitHash, uint256 playerFirstNumber, uint256 playerSecondNumber)"
  }, cfProvider);

  proposeInstall(appFactory);

  cfProvider.on('installVirtual', onInstallEvent);
  cfProvider.on('updateState', onUpdateEvent);
}

async function proposeInstall(appFactory) {
  const { intermediary, nodeAddress } = await getOpponentData();
  const betAmount = '0.00001';
  const initialState = {
      playerAddrs: [
        deriveAddress(
          account.nodeAddress
        ),
        deriveAddress(
          nodeAddress
        )
      ],
      stage: HighRollerStage.PRE_GAME,
      salt: HashZero,
      commitHash: HashZero,
      playerFirstNumber: 0,
      playerSecondNumber: 0
    }

  await appFactory.proposeInstallVirtual({
    initialState,
    proposedToIdentifier: nodeAddress,
    asset: {
      assetType: 0 /* AssetType.ETH */
    },
    peerDeposit: parseEther(betAmount),
    myDeposit: parseEther(betAmount),
    timeout: 172800,
    intermediaries: [intermediary]
  });
}

async function onInstallEvent(event) {
  currentGame.appInstance = event.data.appInstance;

  revealButton();
}

async function onUpdateEvent({ data }) {
  const highRollerState = {
    ...data.newState,
    playerFirstNumber: currentGame.playerFirstNumber
  };

  if (highRollerState.stage === HighRollerStage.REVEALING) {
    await revealDice(highRollerState);
  } else if (highRollerState.stage === HighRollerStage.DONE) {
    await completeGame(highRollerState);
  }
}

async function revealDice(highRollerState) {
  await currentGame.appInstance.takeAction({
    actionType: HighRollerAction.REVEAL,
    actionHash: numberSalt,
    number: highRollerState.playerFirstNumber.toString()
  });
}

async function completeGame(highRollerState) {
  const rolls = await executeContract(
    highRollerState.playerFirstNumber,
    highRollerState.playerSecondNumber
  );

  const { myRoll, opponentRoll } = determineRolls(highRollerState, rolls);
  const gameState = determineGameState(myRoll, opponentRoll);

  updateUIState({
    myRoll,
    opponentRoll,
    gameState,
    highRollerState
  });

  await currentGame.appInstance.uninstall(currentGame.appInstance.intermediaries[0]);

  resetApp();
}

async function roll() {
  disableButton();

  if (currentGame.highRollerState.stage === HighRollerStage.PRE_GAME) {
    await takeAction({
      number: 0,
      actionType: HighRollerAction.START_GAME,
      actionHash: HashZero
    });

    const playerFirstNumber = generatePlayerNumber();

    await takeAction({
      number: 0,
      actionType: HighRollerAction.COMMIT_TO_HASH,
      actionHash: solidityKeccak256(
        ["bytes32", "uint256"],
        [numberSalt, playerFirstNumber]
      )
    });

    currentGame.highRollerState.playerFirstNumber = currentGame.playerFirstNumber = bigNumberify(playerFirstNumber);
  } else {
    await takeAction({
      number: generatePlayerNumber(),
      actionType: HighRollerAction.COMMIT_TO_NUM,
      actionHash: HashZero
    });
  }
}

async function takeAction(params) {
  currentGame.highRollerState = (await currentGame.appInstance.takeAction(
    params
  ));
}


// CONTRACT EXECUTION
async function executeContract(
  num1,
  num2
) {
  const randomness = solidityKeccak256(["uint256"], [num1.mul(num2)]);

  // Connect to the network
  const provider = new ethers.providers.Web3Provider(web3.currentProvider);

  // We connect to the Contract using a Provider, so we will only
  // have read-only access to the Contract
  const contract = new ethers.Contract(contractAddress, abi, provider);

  const result = await contract.highRoller(randomness);

  return {
    playerFirstRoll: getDieNumbers(result[0]),
    playerSecondRoll: getDieNumbers(result[1])
  };
}

function getDieNumbers(totalSum) {
  // Choose result for each die.
  if (totalSum === 12) {
    return [6, 6];
  }

  if (totalSum &gt; 2 &amp;&amp; totalSum &lt; 12) {
    return [Math.floor(totalSum / 2), Math.ceil(totalSum / 2)];
  }

  if (totalSum &gt; 2 &amp;&amp; totalSum % 2 === 0) {
    return [Math.floor(totalSum / 2) - 1, Math.ceil(totalSum / 2) + 1];
  }

  return [totalSum / 2, totalSum / 2];
}


// UI
function updateUIState(uiState) {
  document.querySelector("#gameResult").innerHTML = announceGameState(uiState.gameState);
  document.querySelector("#yourRoll").innerHTML = `Your roll: ${uiState.myRoll[0]} + ${uiState.myRoll[1]}`;
  document.querySelector("#opponentRoll").innerHTML = `Their roll: ${uiState.opponentRoll[0]} + ${uiState.opponentRoll[1]}`;
}

function announceGameState(gameState) {
  switch (gameState) {
    case 1: return "You won!!";
    case 2: return "You lost...";
    case 3: return "You tied?";
  }
}

function hideButton() {
  document.querySelector("#loadingSection").classList.remove("hidden");
  document.querySelector("#rollSection").classList.add("hidden");
}

function revealButton() {
  document.querySelector("#loadingSection").classList.add("hidden");
  document.querySelector("#rollSection").classList.remove("hidden");
}

function disableButton() {
  document.querySelector('#rollBtn').disabled = true;
}

function enableButton() {
  document.querySelector('#rollBtn').disabled = false;
}


// UTILS
function deriveAddress(nodeAddress) {
  return fromExtendedKey(
    nodeAddress
  ).derivePath("0").address
}

function generatePlayerNumber() {
  return 1 + Math.floor(Math.random() * Math.floor(1000));
}

function determineRolls(newState, rolls) {
  const isProposing = newState.stage === HighRollerStage.REVEALING;
  const myRoll = isProposing ? rolls.playerFirstRoll : rolls.playerSecondRoll;
  const opponentRoll = isProposing
    ? rolls.playerSecondRoll
    : rolls.playerFirstRoll;

  return { myRoll, opponentRoll };
}

function determineGameState(myRoll, opponentRoll) {
  const totalMyRoll = myRoll[0] + myRoll[1];
  const totalOpponentRoll = opponentRoll[0] + opponentRoll[1];

  if (totalMyRoll &gt; totalOpponentRoll) {
    return 1;
  } else if (totalMyRoll &lt; totalOpponentRoll) {
    return 2;
  } else {
    return 3;
  }
}

function resetGameState() {
  currentGame = {
    highRollerState: {
      stage: HighRollerStage.PRE_GAME
    }
  };
}

function resetApp() {
  hideButton();
  enableButton();
  install();
}

async function getUserData() {
  return (await requestDataFromPG("playground:request:user", "playground:response:user")).data.user;
}

async function getOpponentData() {
  return (await requestDataFromPG("playground:request:matchmake", "playground:response:matchmake")).data.attributes;
}

async function requestDataFromPG(requestName, responseName) {
  return await new Promise(resolve =&gt; {
    const onPGResponse = (event) =&gt; {
      if (event.data.toString().startsWith(responseName)) {
        window.removeEventListener("message", onPGResponse);

        const [, data] = event.data.split("|");
        resolve(JSON.parse(data));
      } else if (
        event.data.data &amp;&amp;
        typeof event.data.data.message === "string" &amp;&amp;
        event.data.data.message.startsWith(responseName)
      ) {
        window.removeEventListener("message", onPGResponse);

        resolve({ data: event.data.data.data });
      }
    };

    window.addEventListener("message", onPGResponse);

    if (window === window.parent) {
      // dApp not running in iFrame
      window.postMessage(
        {
          type: "PLUGIN_MESSAGE",
          data: { message: requestName }
        },
        "*"
      );
    } else {
      window.parent.postMessage(requestName, "*");
    }
  })
}


// AND GO!!
window.onload = function() {
  run();
};
</code></pre>
          </div>

        </div>
      </div>
    </div>

    <!-- Footer -->
    <div class="section--footer">
      <div class="container">

        <footer class="footer">
          <div class="footer__left">
            <img class="footer__left__logo" src="../assets/logo.svg" alt="Counterfactual">
            <p class="footer__left__text">
              Copyright © 2019 Counterfactual contributors
            </p>
          </div>

          <div class="footer__right">
            <p>
              <a href="http://eepurl.com/dyvKhH" target="_blank">Signup for updates</a> or join us on <a
                href="https://discordapp.com/invite/VcTn7fh">Discord</a>
            </p>
            <a class="twitter" href="https://twitter.com/statechannels" target="_blank">
              <svg id="Logo_FIXED" data-name="Logo — FIXED" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 400">
                <defs>
                  <style>
                    .cls-1 {
                      fill: none;
                    }

                    .cls-2 {
                      fill: #101010;
                    }

                  </style>
                </defs>
                <title>Follow Counterfactual on Twitter</title>
                <rect class="cls-1" width="400" height="400" />
                <path class="cls-2"
                  d="M153.62,301.59c94.34,0,145.94-78.16,145.94-145.94,0-2.22,0-4.43-.15-6.63A104.36,104.36,0,0,0,325,122.47a102.38,102.38,0,0,1-29.46,8.07,51.47,51.47,0,0,0,22.55-28.37,102.79,102.79,0,0,1-32.57,12.45,51.34,51.34,0,0,0-87.41,46.78A145.62,145.62,0,0,1,92.4,107.81a51.33,51.33,0,0,0,15.88,68.47A50.91,50.91,0,0,1,85,169.86c0,.21,0,.43,0,.65a51.31,51.31,0,0,0,41.15,50.28,51.21,51.21,0,0,1-23.16.88,51.35,51.35,0,0,0,47.92,35.62,102.92,102.92,0,0,1-63.7,22A104.41,104.41,0,0,1,75,278.55a145.21,145.21,0,0,0,78.62,23" />
              </svg>
            </a>
          </div>
        </footer>

      </div>
    </div>
    <!-- End Footer -->

  </div>
  <!-- End Wrapper -->

  <script src="/app.js" charset="utf-8"></script>
</body>

</html>
